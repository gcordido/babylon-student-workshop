---
layout: default
title:  "Step Five"
date:   2022-01-04 12:00:00 -0400
categories: jekyll update
---
## Import Model with Animations

For this workshop, we'll use an animated character from <a href="https://www.mixamo.com/">Mixamo</a>. You can leverage Mixamo's pre-made characters and animations for your Babylon.js scenes. The character we'll use has the following animations:

- Idle
- Walking
- Walking Backwards
- Jump

Once an animated character is loaded, the animations are mapped to keyboard inputs so that you can control the character using your **WASD** and **SPACE BAR** keys.

## Code Snippets

### New Camera Settings

The first step before importing our character will be to adjust our camera settings, so that the camera follows our character rather than staying still on the canvas. Replace the code for the **camera** with this snippet, or simply paste it below and comment the previous code out.

```javascript
    //New camera will be active, and be attached to the character once we import it. 
    var camera1 = new BABYLON.ArcRotateCamera("camera1", BABYLON.Tools.ToRadians(-90), Math.PI / 4, 10, new BABYLON.Vector3(0, -5, 0), scene);
    scene.activeCamera = camera1;
    scene.activeCamera.attachControl(canvas, true);
    camera1.lowerRadiusLimit = 2;
    camera1.upperRadiusLimit = 10;
    camera1.wheelDeltaPercentage = 0.01;
```

### Keyboard Input

The next step is to add code that enables keyboard input, so that we can control our character. Add this after the last **tree clone**.

```javascript
    //Registers input and stores it in an inputMap.
    var inputMap = {};
    //The ActionManager object allows for keyboard input to be detected and provides multiple different triggers for other types of input.
    scene.actionManager = new BABYLON.ActionManager(scene);
    //Register actions such as a key being pressed and store its input into our inputmap.
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
    }));
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
    }));
```

### Import Character

The code below imports the 3D model for the character. Add this snippet after the code for **keyboard input** but before `return scene;`.

```javascript
    //Imports a mesh from a .glb file.
    BABYLON.SceneLoader.ImportMesh("", "https://gcordido.github.io/babylon-student-workshop/", "ninja.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
        var hero = newMeshes[0];

        //Scale the model down        
        hero.scaling.scaleInPlace(1.5);

        //Lock camera on the character 
        camera1.target = hero;

        //Hero character variables These can be adjusted to your personal preference.
        var heroSpeed = 0.015;
        var heroSpeedBackwards = 0.01;
        var heroRotationSpeed = 0.01;

        var animating = true;

        //Assigns the different animations to their own constants.
        const walkAnim = scene.getAnimationGroupByName("Walking01");
        const walkBackAnim = scene.getAnimationGroupByName("Walking02");
        const idleAnim = scene.getAnimationGroupByName("Idle");
        const jumpAnim = scene.getAnimationGroupByName("Jump");
    })
```

### Animations

The code below adds the animations for the character. This snippet goes inside the character declaration, that is before the final `})` and before `return scene;`.

```javascript
        //Rendering loop (executed for everyframe)
        scene.onBeforeRenderObservable.add(() => {
            var keydown = false;
            //Manage the movements of the character (e.g. position, direction)
            if (inputMap["w"]) {
                hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
                keydown = true;
            }
            if (inputMap["s"]) {
                hero.moveWithCollisions(hero.forward.scaleInPlace(-heroSpeedBackwards));
                keydown = true;
            }
            if (inputMap["a"]) {
                hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
                keydown = true;
            }
            if (inputMap["d"]) {
                hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
                keydown = true;
            }
            //since we are working with input, space bar input is just an empty space
            if (inputMap[" "]) {
                keydown = true;
            }

             //Manage animations to be played  
            if (keydown) {
                if (!animating) {
                    animating = true;
                    if (inputMap["s"]) {
                        //Walk backwards
                        walkBackAnim.start(true, 1.0, walkBackAnim.from, walkBackAnim.to, false);
                    }
                    else if
                        (inputMap[" "]) {
                        //Jump
                        jumpAnim.start(true, 1.0, jumpAnim.from, jumpAnim.to, false);
                    }
                    else {
                        //Walk
                        walkAnim.start(true, 1.0, walkAnim.from, walkAnim.to, false);
                    }
                }
            }
            else {

                if (animating) {
                    //Default animation is idle when no key is down     
                    idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);

                    //Stop all animations besides Idle Anim when no key is down
                    jumpAnim.stop();
                    walkAnim.stop();
                    walkBackAnim.stop();

                    //Ensure animation are played only once per rendering loop
                    animating = false;
                }
            }
        });
```

## Complete Code

Provided below is the complete code for this step of the workshop.

```javascript
var createScene = function () {

    //Creating a Babylon Scene Object, using the babylon engine.
    var scene = new BABYLON.Scene(engine);

    /** Old Camera Settings
    Create a camera object, which allows us to see the world we're building.
    var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 10, new BABYLON.Vector3(0, 0, 0));
    camera.attachControl(canvas, true);
    */

    //New camera will be active, and be attached to the character once we import it. 
    var camera1 = new BABYLON.ArcRotateCamera("camera1", BABYLON.Tools.ToRadians(-90), Math.PI / 4, 10, new BABYLON.Vector3(0, -5, 0), scene);
    scene.activeCamera = camera1;
    scene.activeCamera.attachControl(canvas, true);
    camera1.lowerRadiusLimit = 2;
    camera1.upperRadiusLimit = 10;
    camera1.wheelDeltaPercentage = 0.01;

    //Creates a hemispheric light for the scene (allows for visibility of our objects)
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    /**** Sky Color *****/
    scene.clearColor = BABYLON.Color3.Black();

    //Creates a ground object, which allows us to have a more world-like scene, as well as guidance as to where to drop future objects.
    var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 40, height: 40}, scene);


    //This provides our ground with a given texture, by first declaring the material object
    var groundMat = new BABYLON.StandardMaterial("groundMaterial");
    //We define where the texture for the material is coming from
    groundMat.diffuseTexture = new BABYLON.Texture("https://raw.githubusercontent.com/gcordido/babylon-student-workshop/gh-pages/textures/grass.jpg", scene);
    //And determine how we want to spread said texture across the ground.
    groundMat.diffuseTexture.uScale = 6;
    groundMat.diffuseTexture.vScale = 6;
    //Finally, we assign the groundMat object as the our ground object's material.
    ground.material = groundMat;


    //We declare a wall object that covers the ends of our ground on one side
    const wall = BABYLON.MeshBuilder.CreateBox("wall", {height: 10, width: 40, depth: 0.125});
    //Declare its material
    const wallMat = new BABYLON.StandardMaterial("wallMat");
    wallMat.diffuseTexture = new BABYLON.Texture("https://raw.githubusercontent.com/gcordido/babylon-student-workshop/gh-pages/textures/forest.jpg");
    wall.material = wallMat;
    //And adjust its position
    wall.position.y =  2;
    wall.position.z = 20;

    //Cloning the original wall to recreate the rest of the forest
    const wall2 = wall.clone("wall2");
    wall2.rotation.y = BABYLON.Tools.ToRadians(-90);
    //Adjust its position to each of the ends of the ground
    wall2.position.x = -20;
    wall2.position.z = 0;

    const wall3 = wall.clone("wall3");
    wall3.rotation.y = BABYLON.Tools.ToRadians(90);
    wall3.position.x = 20;
    wall3.position.z = 0;

    const wall4 = wall.clone("wall4");
    wall4.position.x = 0;
    wall4.rotation.z = BABYLON.Tools.ToRadians(-180);
    wall4.position.z = -20;
    
    //To add some trees, we will recreate them using columns!
    const tree = BABYLON.MeshBuilder.CreateBox("tree", {height: 4, width: 0.50, depth: .50});
    const darkWoodMat = new BABYLON.StandardMaterial("darkWoodMat");
    darkWoodMat.diffuseTexture = new BABYLON.Texture("https://raw.githubusercontent.com/gcordido/babylon-student-workshop/gh-pages/textures/black-wood.jpg")
    tree.material = darkWoodMat;
    tree.position.y = 2;
    tree.position.x = -2;
    tree.position.z = -1;

    const tree2 = tree.clone("tree2");
    tree2.position.x = 2;
    
    /**Keyboard Input */
    //Registers input and stores it in an inputMap.
    var inputMap = {};
    //The ActionManager object allows for keyboard input to be detected and provides multiple different triggers for other types of input.
    scene.actionManager = new BABYLON.ActionManager(scene);
    //Register actions such as a key being pressed and store its input into our inputmap.
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
    }));
    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
    }));

    /** Character Import */
    //Imports a mesh from a .glb file.
    BABYLON.SceneLoader.ImportMesh("", "https://gcordido.github.io/babylon-student-workshop/", "ninja.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
        var hero = newMeshes[0];

        //Scale the model down        
        hero.scaling.scaleInPlace(1.5);

        //Lock camera on the character 
        camera1.target = hero;

        //Hero character variables These can be adjusted to your personal preference.
        var heroSpeed = 0.015;
        var heroSpeedBackwards = 0.01;
        var heroRotationSpeed = 0.01;

        var animating = true;

        //Assigns the different animations to their own constants.
        const walkAnim = scene.getAnimationGroupByName("Walking01");
        const walkBackAnim = scene.getAnimationGroupByName("Walking02");
        const idleAnim = scene.getAnimationGroupByName("Idle");
        const jumpAnim = scene.getAnimationGroupByName("Jump");


        //Rendering loop (executed for everyframe)
        scene.onBeforeRenderObservable.add(() => {
            var keydown = false;
            //Manage the movements of the character (e.g. position, direction)
            if (inputMap["w"]) {
                hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
                keydown = true;
            }
            if (inputMap["s"]) {
                hero.moveWithCollisions(hero.forward.scaleInPlace(-heroSpeedBackwards));
                keydown = true;
            }
            if (inputMap["a"]) {
                hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
                keydown = true;
            }
            if (inputMap["d"]) {
                hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
                keydown = true;
            }
            if (inputMap[" "]) {
                keydown = true;
            }

            //Manage animations to be played  
            if (keydown) {
                if (!animating) {
                    animating = true;
                    if (inputMap["s"]) {
                        //Walk backwards
                        walkBackAnim.start(true, 1.0, walkBackAnim.from, walkBackAnim.to, false);
                    }
                    else if
                        (inputMap[" "]) {
                        //Jump
                        jumpAnim.start(true, 1.0, jumpAnim.from, jumpAnim.to, false);
                    }
                    else {
                        //Walk
                        walkAnim.start(true, 1.0, walkAnim.from, walkAnim.to, false);
                    }
                }
            }
            else {

                if (animating) {
                    //Default animation is idle when no key is down     
                    idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);

                    //Stop all animations besides Idle Anim when no key is down
                    jumpAnim.stop();
                    walkAnim.stop();
                    walkBackAnim.stop();

                    //Ensure animation are played only once per rendering loop
                    animating = false;
                }
            }
        });
    })

    return scene;
};
```

<ul class="actions">
<li><a href="https://gcordido.github.io/babylon-student-workshop/jekyll/update/2022/01/05/step-four.html" class="button special">Back</a></li>
<li><a href="https://gcordido.github.io/babylon-student-workshop/jekyll/update/2022/01/03/step-six.html" class="button">Next</a></li>
</ul>